#  设计模式

## 创建型设计模式
### Factory（工厂）
* 不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂,**只关心结果，不关心过程**， 外部不许关心内部构造器是怎么生成的，只需调用一个工厂方法生成一个实例即可；**通过工厂模式我们得到的都是对象实例或者抽象工厂**。

### Builder（建造者）
* **更关心创建对象的整个过程，甚至于创建对象的每一个细节**。将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。**客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象**。

### Prototype
1. js是基于原型链实现对象之间的继承，是基于对象属性或方法的**共享**，而不是对对象属性的复制。创建一个基类时，不必将每个属性和方法都放在构造函数constructor里面，为了提高性能，放在原型上共享。**将可复用，可共享，耗时大的从基类中提取出来放到原型中**。
2. 在prototype上浏览器天生给它加了一个属性：constructor（构造函数），属性值是当前函数（类）本身；
3. ES6 的class可以看作只是一个语法糖

### Proxy
* 一个对象不能直接引用另一个对象，通过代理对象起中介作用。
1. es6, proxy
2. 事件代理

### Adapte
* 适配器往往适用于两个接口不兼容的问题；
1. 在js中，适配两个代码库，适配前后端数据等，window.A = A = jQuery
2. 比如连接不同数据库的情况，你需要包装现有的模块接口，从而使之适配数据库 

### Decorator
1. 在不改变原有类，原有接口的情况下表现的更好
   - 水可以直接喝，加上果汁更好喝
   - 手机贴不贴膜可以用，有些人就喜欢加个外壳防摔
2. es7 Decorator
   - 参数同Object.defineProperty参数一致
3. ES7 的 decorator，作用就是返回一个新的 descriptor，并把这个新返回的 descriptor 应用到目标方法上
4. 作用在方法上的 decorator 接收的第一个参数（target ）是类的 prototype
5. 如果把一个 decorator 作用到类上，则它的第一个参数 target 是 类本身。

### Observer
1. 观察者模式又称发布-订阅模式或消息机制，定义了一种依赖关系，解决了主题对象与观察者之间功能的耦合
2. 事件绑定
3. promise
4. nodejs自定义事件
5. vue，react的生命周期
6. vue wacth
7. 主题与观察者分离，不是主动触发，而是被动监听，两者解耦

### State

```js
    if(type === 'a') {return <A/>}
    if(type === 'b') {return <B/>}
    if(type === 'c') {return <C/>}
    // 多if或switch，改写成对象的形式
    let obj = {
        a: <A/>,
        b: <B/>,
        c: <C/>
    }
```

### Iterator
1. 为各种数据结构提供统一的遍历接口，如 Array，Map，Set，argument，nodeList等；
2. 必须为有序集合，object不是
3. for...of循环，内部实际上是调用有序集合的Symbol.iterator的属性方法；
4. typeof Symbol.iterator === 'function'，可遍历，调用Symbol.iterator可生成一个迭代器
```js
    // 生成一个迭代器 
    let iterator = data[Symbol.iterator]()
```


